"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[9306],{7243:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"book-tutorial/module-2/integration/gazebo-unity-integration","title":"Gazebo-Unity Integration Guide","description":"Integrating Gazebo and Unity creates a powerful digital twin system combining accurate physics simulation with high-fidelity visualization. This chapter details the architecture, communication protocols, and implementation strategies for seamless integration.","source":"@site/docs/book-tutorial/module-2/integration/gazebo-unity-integration.md","sourceDirName":"book-tutorial/module-2/integration","slug":"/book-tutorial/module-2/integration/gazebo-unity-integration","permalink":"/physical-ai-book/docs/book-tutorial/module-2/integration/gazebo-unity-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book-tutorial/module-2/integration/gazebo-unity-integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Gazebo-Unity Integration Guide"},"sidebar":"bookTutorial","previous":{"title":"Digital Twin Data Model","permalink":"/physical-ai-book/docs/book-tutorial/module-2/data-model/"},"next":{"title":"Physics Simulation with Gazebo","permalink":"/physical-ai-book/docs/book-tutorial/module-2/physics/physics-simulation"}}');var i=r(4848),o=r(8453);const a={sidebar_position:4,title:"Gazebo-Unity Integration Guide"},s="Gazebo-Unity Integration Guide",l={},c=[{value:"Integration Architecture Overview",id:"integration-architecture-overview",level:2},{value:"System Components",id:"system-components",level:3},{value:"Communication Protocols",id:"communication-protocols",level:2},{value:"ROS Bridge Approach",id:"ros-bridge-approach",level:3},{value:"Setting up ROS Bridge Server",id:"setting-up-ros-bridge-server",level:4},{value:"Unity ROS Bridge Client",id:"unity-ros-bridge-client",level:4},{value:"Custom TCP/IP Communication",id:"custom-tcpip-communication",level:3},{value:"Synchronization Strategies",id:"synchronization-strategies",level:2},{value:"Time Synchronization",id:"time-synchronization",level:3},{value:"State Interpolation",id:"state-interpolation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Data Transmission",id:"efficient-data-transmission",level:3},{value:"Data Compression for Sensor Streams",id:"data-compression-for-sensor-streams",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Connection Resilience",id:"connection-resilience",level:3},{value:"Best Practices for Integration",id:"best-practices-for-integration",level:2},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Synchronization Problems",id:"synchronization-problems",level:3},{value:"Performance Bottlenecks",id:"performance-bottlenecks",level:3},{value:"Data Integrity",id:"data-integrity",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"gazebo-unity-integration-guide",children:"Gazebo-Unity Integration Guide"})}),"\n",(0,i.jsx)(e.p,{children:"Integrating Gazebo and Unity creates a powerful digital twin system combining accurate physics simulation with high-fidelity visualization. This chapter details the architecture, communication protocols, and implementation strategies for seamless integration."}),"\n",(0,i.jsx)(e.h2,{id:"integration-architecture-overview",children:"Integration Architecture Overview"}),"\n",(0,i.jsx)(e.p,{children:"The Gazebo-Unity integration follows a distributed architecture where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gazebo"})," handles physics simulation, sensor modeling, and robot dynamics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Unity"})," provides high-quality visualization and user interaction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Communication Layer"})," synchronizes state between both systems"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"system-components",children:"System Components"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Client    \u2502    \u2502 Communication   \u2502    \u2502   Digital   \u2502\r\n\u2502 Application \u2502\u25c4\u2500\u2500\u25ba\u2502     Layer       \u2502\u25c4\u2500\u2500\u25ba\u2502   Twin      \u2502\r\n\u2502             \u2502    \u2502                 \u2502    \u2502   System    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                        \u25b2    \u25b2                   \u2502\r\n                        \u2502    \u2502                   \u2502\r\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n                 \u2502           \u2502                   \u2502\r\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510\r\n        \u2502   Gazebo  \u2502 \u2502 Message   \u2502    \u2502   Unity   \u2502\r\n        \u2502 Simulation\u2502 \u2502 Queue     \u2502    \u2502 Renderer  \u2502\r\n        \u2502   Core    \u2502 \u2502 Service   \u2502    \u2502   Core    \u2502\r\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(e.h2,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,i.jsx)(e.h3,{id:"ros-bridge-approach",children:"ROS Bridge Approach"}),"\n",(0,i.jsx)(e.p,{children:"Using rosbridge_suite provides a flexible communication mechanism:"}),"\n",(0,i.jsx)(e.h4,{id:"setting-up-ros-bridge-server",children:"Setting up ROS Bridge Server"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Install rosbridge\r\nsudo apt-get install ros-noetic-rosbridge-suite\r\n\r\n# Launch websocket bridge\r\nroslaunch rosbridge_server rosbridge_websocket.launch\n"})}),"\n",(0,i.jsx)(e.h4,{id:"unity-ros-bridge-client",children:"Unity ROS Bridge Client"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing RosSharp.RosBridgeClient;\r\n\r\npublic class GazeboUnityBridge : MonoBehaviour\r\n{\r\n    [Header("ROS Connection")]\r\n    public string rosBridgeUrl = "ws://localhost:9090";\r\n\r\n    [Header("Robot State Topics")]\r\n    public string jointStatesTopic = "/joint_states";\r\n    public string tfTopic = "/tf";\r\n    public string sensorDataTopic = "/sensor_data";\r\n\r\n    [Header("Control Topics")]\r\n    public string jointCmdTopic = "/joint_commands";\r\n\r\n    private RosSocket rosSocket;\r\n    private Dictionary<string, JointState> jointStates = new Dictionary<string, JointState>();\r\n    private Dictionary<string, Transform> jointTransforms = new Dictionary<string, Transform>();\r\n\r\n    void Start()\r\n    {\r\n        ConnectToRosBridge();\r\n    }\r\n\r\n    void ConnectToRosBridge()\r\n    {\r\n        RosBridgeClient.Protocols.WebSocketNetProtocol protocol =\r\n            new RosBridgeClient.Protocols.WebSocketNetProtocol(rosBridgeUrl);\r\n\r\n        rosSocket = new RosSocket(protocol, RosSocket.Scheduler.UnityMainThread);\r\n\r\n        // Subscribe to topics\r\n        SubscribeToTopics();\r\n\r\n        // Advertise publishers if needed\r\n        // PublishToTopics();\r\n    }\r\n\r\n    void SubscribeToTopics()\r\n    {\r\n        // Subscribe to joint states\r\n        rosSocket.Subscribe<JointStateMessage>(jointStatesTopic, ProcessJointStates);\r\n\r\n        // Subscribe to transforms\r\n        rosSocket.Subscribe<TFMessage>(tfTopic, ProcessTransforms);\r\n\r\n        // Subscribe to sensor data\r\n        rosSocket.Subscribe<SensorDataMessage>(sensorDataTopic, ProcessSensorData);\r\n    }\r\n\r\n    void ProcessJointStates(JointStateMessage jointStateMsg)\r\n    {\r\n        for (int i = 0; i < jointStateMsg.name.Count; i++)\r\n        {\r\n            string jointName = jointStateMsg.name[i];\r\n            double position = jointStateMsg.position[i];\r\n\r\n            if (jointTransforms.ContainsKey(jointName))\r\n            {\r\n                // Update Unity transform based on joint position\r\n                Transform jointTransform = jointTransforms[jointName];\r\n\r\n                // Convert radians to degrees for rotation\r\n                jointTransform.localRotation = Quaternion.Euler(0, 0, (float)position * Mathf.Rad2Deg);\r\n            }\r\n        }\r\n    }\r\n\r\n    void ProcessTransforms(TFMessage tfMessage)\r\n    {\r\n        foreach (var transform in tfMessage.transforms)\r\n        {\r\n            string frameId = transform.child_frame_id;\r\n\r\n            // Update Unity object positions based on TF transforms\r\n            GameObject unityObject = GameObject.Find(frameId);\r\n            if (unityObject != null)\r\n            {\r\n                unityObject.transform.position = new Vector3(\r\n                    (float)transform.transform.translation.x,\r\n                    (float)transform.transform.translation.y,\r\n                    (float)transform.transform.translation.z\r\n                );\r\n\r\n                unityObject.transform.rotation = new Quaternion(\r\n                    (float)transform.transform.rotation.x,\r\n                    (float)transform.transform.rotation.y,\r\n                    (float)transform.transform.rotation.z,\r\n                    (float)transform.transform.rotation.w\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    void ProcessSensorData(SensorDataMessage sensorData)\r\n    {\r\n        // Process sensor data for visualization\r\n        switch (sensorData.sensor_type)\r\n        {\r\n            case "lidar":\r\n                VisualizeLidarData(sensorData.data);\r\n                break;\r\n            case "camera":\r\n                UpdateCameraFeed(sensorData.image_data);\r\n                break;\r\n            case "imu":\r\n                UpdateIMUVisualization(sensorData.data);\r\n                break;\r\n        }\r\n    }\r\n\r\n    void VisualizeLidarData(float[] ranges)\r\n    {\r\n        // Implement LiDAR visualization\r\n    }\r\n\r\n    void UpdateCameraFeed(byte[] imageData)\r\n    {\r\n        // Update camera feed texture\r\n    }\r\n\r\n    void UpdateIMUVisualization(float[] imuData)\r\n    {\r\n        // Update IMU visualization indicators\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class JointStateMessage\r\n    {\r\n        public List<string> name = new List<string>();\r\n        public List<double> position = new List<double>();\r\n        public List<double> velocity = new List<double>();\r\n        public List<double> effort = new List<double>();\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class TFMessage\r\n    {\r\n        public List<TransformStamped> transforms = new List<TransformStamped>();\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class TransformStamped\r\n    {\r\n        public string child_frame_id;\r\n        public Transform transform;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Transform\r\n    {\r\n        public Vector3 translation;\r\n        public Rotation rotation;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Vector3\r\n    {\r\n        public double x, y, z;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Rotation\r\n    {\r\n        public double x, y, z, w;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class SensorDataMessage\r\n    {\r\n        public string sensor_type;\r\n        public float[] data;\r\n        public byte[] image_data;\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"custom-tcpip-communication",children:"Custom TCP/IP Communication"}),"\n",(0,i.jsx)(e.p,{children:"For direct communication without ROS overhead:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Gazebo-side publisher (Python)\r\nimport socket\r\nimport json\r\nimport threading\r\nimport time\r\n\r\nclass GazeboPublisher:\r\n    def __init__(self, host='localhost', port=5000):\r\n        self.host = host\r\n        self.port = port\r\n        self.clients = []\r\n        self.running = False\r\n\r\n    def start_server(self):\r\n        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n        self.server_socket.bind((self.host, self.port))\r\n        self.server_socket.listen(5)\r\n\r\n        self.running = True\r\n        accept_thread = threading.Thread(target=self.accept_connections)\r\n        accept_thread.start()\r\n\r\n        print(f\"Gazebo Publisher listening on {self.host}:{self.port}\")\r\n\r\n    def accept_connections(self):\r\n        while self.running:\r\n            try:\r\n                client_socket, address = self.server_socket.accept()\r\n                print(f\"Unity client connected: {address}\")\r\n                self.clients.append(client_socket)\r\n\r\n                # Send initial state\r\n                initial_state = self.get_robot_state()\r\n                self.send_to_client(client_socket, initial_state)\r\n\r\n            except Exception as e:\r\n                if self.running:\r\n                    print(f\"Error accepting connections: {e}\")\r\n\r\n    def send_state_updates(self):\r\n        \"\"\"Send periodic state updates to all connected clients\"\"\"\r\n        while self.running:\r\n            try:\r\n                robot_state = self.get_robot_state()\r\n                sensor_data = self.get_sensor_data()\r\n\r\n                message = {\r\n                    'timestamp': time.time(),\r\n                    'robot_state': robot_state,\r\n                    'sensor_data': sensor_data\r\n                }\r\n\r\n                self.broadcast_message(message)\r\n                time.sleep(0.01)  # 100Hz update rate\r\n\r\n            except Exception as e:\r\n                print(f\"Error sending state updates: {e}\")\r\n                time.sleep(0.1)\r\n\r\n    def broadcast_message(self, message):\r\n        \"\"\"Send message to all connected clients\"\"\"\r\n        message_json = json.dumps(message)\r\n        message_bytes = message_json.encode('utf-8')\r\n\r\n        disconnected_clients = []\r\n        for client in self.clients:\r\n            try:\r\n                client.send(message_bytes)\r\n            except Exception as e:\r\n                print(f\"Removing disconnected client: {e}\")\r\n                disconnected_clients.append(client)\r\n\r\n        # Remove disconnected clients\r\n        for client in disconnected_clients:\r\n            self.clients.remove(client)\r\n\r\n    def get_robot_state(self):\r\n        \"\"\"Get current robot state from Gazebo\"\"\"\r\n        # This would interface with Gazebo's transport system\r\n        # Return dictionary with position, orientation, joint angles, etc.\r\n        return {\r\n            'position': {'x': 0.0, 'y': 0.0, 'z': 0.0},\r\n            'orientation': {'roll': 0.0, 'pitch': 0.0, 'yaw': 0.0},\r\n            'joint_angles': [0.0, 0.0, 0.0],\r\n            'linear_velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0},\r\n            'angular_velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0}\r\n        }\r\n\r\n    def get_sensor_data(self):\r\n        \"\"\"Get current sensor readings from Gazebo\"\"\"\r\n        return {\r\n            'lidar': {'ranges': [10.0] * 360, 'angle_min': -3.14, 'angle_max': 3.14},\r\n            'camera': {'image_width': 640, 'image_height': 480, 'encoding': 'rgb8'},\r\n            'imu': {'acceleration': {'x': 0.0, 'y': 0.0, 'z': 9.81},\r\n                   'angular_velocity': {'x': 0.0, 'y': 0.0, 'z': 0.0}}\r\n        }\r\n\r\n    def send_to_client(self, client_socket, message):\r\n        \"\"\"Send message to specific client\"\"\"\r\n        try:\r\n            message_json = json.dumps(message)\r\n            client_socket.send(message_json.encode('utf-8'))\r\n        except Exception as e:\r\n            print(f\"Error sending to client: {e}\")\r\n\r\n# Initialize and start publisher\r\npublisher = GazeboPublisher()\r\npublisher.start_server()\r\n\r\n# Start state update loop\r\nstate_thread = threading.Thread(target=publisher.send_state_updates)\r\nstate_thread.start()\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'// Unity-side receiver (C#)\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing System.Net.Sockets;\r\nusing System.Text;\r\nusing Newtonsoft.Json;\r\n\r\npublic class GazeboDataReceiver : MonoBehaviour\r\n{\r\n    [Header("Connection Settings")]\r\n    public string gazeboHost = "localhost";\r\n    public int gazeboPort = 5000;\r\n\r\n    [Header("Robot References")]\r\n    public Transform robotRoot;\r\n    public List<Transform> jointTransforms = new List<Transform>();\r\n    public List<string> jointNames = new List<string>();\r\n\r\n    [Header("Sensor Visualization")]\r\n    public GameObject lidarVisualization;\r\n    public GameObject cameraFeedDisplay;\r\n\r\n    private TcpClient tcpClient;\r\n    private NetworkStream stream;\r\n    private bool isConnected = false;\r\n\r\n    void Start()\r\n    {\r\n        StartCoroutine(ConnectToGazebo());\r\n    }\r\n\r\n    IEnumerator ConnectToGazebo()\r\n    {\r\n        while (!isConnected)\r\n        {\r\n            try\r\n            {\r\n                tcpClient = new TcpClient(gazeboHost, gazeboPort);\r\n                stream = tcpClient.GetStream();\r\n                isConnected = true;\r\n\r\n                Debug.Log("Connected to Gazebo simulation");\r\n\r\n                // Start receiving data\r\n                StartCoroutine(ReceiveData());\r\n            }\r\n            catch (System.Exception e)\r\n            {\r\n                Debug.LogError($"Connection failed: {e.Message}");\r\n                yield return new WaitForSeconds(2f); // Retry after 2 seconds\r\n            }\r\n        }\r\n    }\r\n\r\n    IEnumerator ReceiveData()\r\n    {\r\n        byte[] buffer = new byte[8192]; // Increased buffer size for sensor data\r\n\r\n        while (isConnected && tcpClient.Connected)\r\n        {\r\n            try\r\n            {\r\n                int bytesRead = stream.Read(buffer, 0, buffer.Length);\r\n                if (bytesRead > 0)\r\n                {\r\n                    string data = Encoding.UTF8.GetString(buffer, 0, bytesRead);\r\n\r\n                    // Process received data\r\n                    ProcessReceivedData(data);\r\n                }\r\n            }\r\n            catch (System.Exception e)\r\n            {\r\n                Debug.LogError($"Error receiving data: {e.Message}");\r\n                isConnected = false;\r\n                break;\r\n            }\r\n\r\n            yield return null; // Yield to avoid blocking\r\n        }\r\n    }\r\n\r\n    void ProcessReceivedData(string jsonData)\r\n    {\r\n        try\r\n        {\r\n            // Parse JSON data from Gazebo\r\n            GazeboState state = JsonConvert.DeserializeObject<GazeboState>(jsonData);\r\n\r\n            // Update robot position and orientation\r\n            UpdateRobotPosition(state.robot_state);\r\n\r\n            // Update joint positions\r\n            UpdateJointPositions(state.robot_state);\r\n\r\n            // Process sensor data\r\n            ProcessSensorData(state.sensor_data);\r\n        }\r\n        catch (System.Exception e)\r\n        {\r\n            Debug.LogError($"Error parsing JSON data: {e.Message}");\r\n        }\r\n    }\r\n\r\n    void UpdateRobotPosition(RobotState robotState)\r\n    {\r\n        if (robotRoot != null)\r\n        {\r\n            robotRoot.position = new Vector3(\r\n                (float)robotState.position.x,\r\n                (float)robotState.position.y,\r\n                (float)robotState.position.z\r\n            );\r\n\r\n            robotRoot.rotation = Quaternion.Euler(\r\n                (float)robotState.orientation.roll * Mathf.Rad2Deg,\r\n                (float)robotState.orientation.yaw * Mathf.Rad2Deg,\r\n                (float)robotState.orientation.pitch * Mathf.Rad2Deg\r\n            );\r\n        }\r\n    }\r\n\r\n    void UpdateJointPositions(RobotState robotState)\r\n    {\r\n        for (int i = 0; i < jointTransforms.Count && i < robotState.joint_angles.Count; i++)\r\n        {\r\n            if (jointTransforms[i] != null)\r\n            {\r\n                jointTransforms[i].localRotation = Quaternion.Euler(\r\n                    0, 0, (float)robotState.joint_angles[i] * Mathf.Rad2Deg\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    void ProcessSensorData(SensorData sensorData)\r\n    {\r\n        // Visualize LiDAR data\r\n        if (lidarVisualization != null)\r\n        {\r\n            UpdateLidarVisualization(sensorData.lidar);\r\n        }\r\n\r\n        // Update camera feed (would require image data processing)\r\n        if (cameraFeedDisplay != null)\r\n        {\r\n            // Process camera image data\r\n        }\r\n    }\r\n\r\n    void UpdateLidarVisualization(LidarData lidarData)\r\n    {\r\n        // Implementation for visualizing LiDAR data\r\n        // Could use particle systems, line renderers, or point clouds\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class GazeboState\r\n    {\r\n        public double timestamp;\r\n        public RobotState robot_state;\r\n        public SensorData sensor_data;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class RobotState\r\n    {\r\n        public Position position;\r\n        public Orientation orientation;\r\n        public List<double> joint_angles = new List<double>();\r\n        public Velocity linear_velocity;\r\n        public Velocity angular_velocity;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Position\r\n    {\r\n        public double x, y, z;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Orientation\r\n    {\r\n        public double roll, pitch, yaw;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Velocity\r\n    {\r\n        public double x, y, z;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class SensorData\r\n    {\r\n        public LidarData lidar;\r\n        public CameraData camera;\r\n        public ImuData imu;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class LidarData\r\n    {\r\n        public List<double> ranges = new List<double>();\r\n        public double angle_min;\r\n        public double angle_max;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class CameraData\r\n    {\r\n        public int image_width;\r\n        public int image_height;\r\n        public string encoding;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class ImuData\r\n    {\r\n        public Acceleration acceleration;\r\n        public AngularVelocity angular_velocity;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class Acceleration\r\n    {\r\n        public double x, y, z;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class AngularVelocity\r\n    {\r\n        public double x, y, z;\r\n    }\r\n\r\n    void OnDestroy()\r\n    {\r\n        isConnected = false;\r\n        if (tcpClient != null)\r\n        {\r\n            tcpClient.Close();\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"synchronization-strategies",children:"Synchronization Strategies"}),"\n",(0,i.jsx)(e.h3,{id:"time-synchronization",children:"Time Synchronization"}),"\n",(0,i.jsx)(e.p,{children:"Maintaining temporal coherence between systems is crucial:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using System.Collections;\r\nusing UnityEngine;\r\n\r\npublic class TimeSynchronizer : MonoBehaviour\r\n{\r\n    [Header("Synchronization Settings")]\r\n    public float gazeboTimeStep = 0.001f;  // Gazebo physics update rate\r\n    public float unityTargetFPS = 60f;     // Unity target frame rate\r\n    public bool enableTimeLocking = true;\r\n\r\n    private double gazeboTime = 0.0;\r\n    private double unityTime = 0.0;\r\n    private double timeOffset = 0.0;\r\n    private bool isSynchronized = false;\r\n\r\n    void Update()\r\n    {\r\n        if (enableTimeLocking && isSynchronized)\r\n        {\r\n            // Adjust Unity time scale to match Gazebo pace\r\n            double deltaTime = gazeboTime - unityTime;\r\n\r\n            if (Mathf.Abs((float)deltaTime) > 0.1) // 100ms tolerance\r\n            {\r\n                // Adjust time scale to catch up or slow down\r\n                float adjustment = (float)(deltaTime * 0.1f);\r\n                Time.timeScale = Mathf.Clamp(1.0f + adjustment, 0.5f, 2.0f);\r\n            }\r\n            else\r\n            {\r\n                Time.timeScale = 1.0f;\r\n            }\r\n        }\r\n\r\n        unityTime += Time.deltaTime;\r\n    }\r\n\r\n    public void UpdateGazeboTime(double gazeboTimestamp)\r\n    {\r\n        if (!isSynchronized)\r\n        {\r\n            // Establish initial synchronization\r\n            timeOffset = gazeboTimestamp - unityTime;\r\n            isSynchronized = true;\r\n        }\r\n\r\n        gazeboTime = gazeboTimestamp;\r\n    }\r\n\r\n    public double GetSynchronizedTime()\r\n    {\r\n        return isSynchronized ? gazeboTime : unityTime;\r\n    }\r\n\r\n    public float GetTimeDifference()\r\n    {\r\n        return (float)(gazeboTime - unityTime);\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"state-interpolation",children:"State Interpolation"}),"\n",(0,i.jsx)(e.p,{children:"Smooth transitions between discrete state updates:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\npublic class StateInterpolator : MonoBehaviour\r\n{\r\n    [Header("Interpolation Settings")]\r\n    public int maxHistoryPoints = 10;\r\n    public float interpolationDelay = 0.05f; // 50ms delay for smooth interpolation\r\n\r\n    private Queue<StateSnapshot> stateHistory = new Queue<StateSnapshot>();\r\n    private TimeSynchronizer timeSync;\r\n\r\n    void Start()\r\n    {\r\n        timeSync = GetComponent<TimeSynchronizer>();\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        if (stateHistory.Count >= 2)\r\n        {\r\n            InterpolateToTarget();\r\n        }\r\n    }\r\n\r\n    public void AddStateSnapshot(StateSnapshot snapshot)\r\n    {\r\n        stateHistory.Enqueue(snapshot);\r\n\r\n        // Limit history size\r\n        if (stateHistory.Count > maxHistoryPoints)\r\n        {\r\n            stateHistory.Dequeue();\r\n        }\r\n    }\r\n\r\n    void InterpolateToTarget()\r\n    {\r\n        // Get the target state that should be reached after interpolation delay\r\n        double targetTime = timeSync.GetSynchronizedTime() + interpolationDelay;\r\n\r\n        // Find the closest states for interpolation\r\n        StateSnapshot prev = null, next = null;\r\n\r\n        // Convert queue to list for easier access\r\n        var historyList = new List<StateSnapshot>(stateHistory);\r\n\r\n        for (int i = 0; i < historyList.Count - 1; i++)\r\n        {\r\n            if (historyList[i].timestamp <= targetTime && historyList[i + 1].timestamp >= targetTime)\r\n            {\r\n                prev = historyList[i];\r\n                next = historyList[i + 1];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (prev != null && next != null)\r\n        {\r\n            float t = (float)((targetTime - prev.timestamp) / (next.timestamp - prev.timestamp));\r\n            ApplyInterpolatedState(prev, next, Mathf.Clamp01(t));\r\n        }\r\n    }\r\n\r\n    void ApplyInterpolatedState(StateSnapshot prev, StateSnapshot next, float t)\r\n    {\r\n        // Interpolate position\r\n        Vector3 interpolatedPos = Vector3.Lerp(\r\n            new Vector3((float)prev.position.x, (float)prev.position.y, (float)prev.position.z),\r\n            new Vector3((float)next.position.x, (float)next.position.y, (float)next.position.z),\r\n            t\r\n        );\r\n\r\n        // Interpolate rotation\r\n        Quaternion interpolatedRot = Quaternion.Slerp(\r\n            Quaternion.Euler(\r\n                (float)prev.orientation.roll * Mathf.Rad2Deg,\r\n                (float)prev.orientation.yaw * Mathf.Rad2Deg,\r\n                (float)prev.orientation.pitch * Mathf.Rad2Deg\r\n            ),\r\n            Quaternion.Euler(\r\n                (float)next.orientation.roll * Mathf.Rad2Deg,\r\n                (float)next.orientation.yaw * Mathf.Rad2Deg,\r\n                (float)next.orientation.pitch * Mathf.Rad2Deg\r\n            ),\r\n            t\r\n        );\r\n\r\n        // Apply to robot transform\r\n        transform.position = interpolatedPos;\r\n        transform.rotation = interpolatedRot;\r\n\r\n        // Interpolate joint angles\r\n        for (int i = 0; i < jointTransforms.Count && i < prev.jointAngles.Count && i < next.jointAngles.Count; i++)\r\n        {\r\n            if (jointTransforms[i] != null)\r\n            {\r\n                float interpolatedAngle = Mathf.Lerp(\r\n                    (float)prev.jointAngles[i],\r\n                    (float)next.jointAngles[i],\r\n                    t\r\n                );\r\n\r\n                jointTransforms[i].localRotation = Quaternion.Euler(0, 0, interpolatedAngle * Mathf.Rad2Deg);\r\n            }\r\n        }\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class StateSnapshot\r\n    {\r\n        public double timestamp;\r\n        public Position position;\r\n        public Orientation orientation;\r\n        public List<double> jointAngles = new List<double>();\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"efficient-data-transmission",children:"Efficient Data Transmission"}),"\n",(0,i.jsx)(e.p,{children:"Minimize network overhead with smart serialization:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Efficient binary serialization for Gazebo data\r\nimport struct\r\nimport numpy as np\r\n\r\nclass EfficientSerializer:\r\n    def serialize_robot_state(self, state_dict):\r\n        \"\"\"\r\n        Serialize robot state efficiently using binary format\r\n        Format: timestamp(8) + pos(24) + orient(24) + joint_count(4) + joints(N*8)\r\n        Total: 56 + N*8 bytes where N is number of joints\r\n        \"\"\"\r\n        data = bytearray()\r\n\r\n        # Timestamp (double - 8 bytes)\r\n        data.extend(struct.pack('d', state_dict['timestamp']))\r\n\r\n        # Position (3 doubles - 24 bytes)\r\n        data.extend(struct.pack('ddd',\r\n            state_dict['position']['x'],\r\n            state_dict['position']['y'],\r\n            state_dict['position']['z']\r\n        ))\r\n\r\n        # Orientation (3 doubles - 24 bytes)\r\n        data.extend(struct.pack('ddd',\r\n            state_dict['orientation']['roll'],\r\n            state_dict['orientation']['pitch'],\r\n            state_dict['orientation']['yaw']\r\n        ))\r\n\r\n        # Joint angles\r\n        joint_angles = state_dict['joint_angles']\r\n        data.extend(struct.pack('I', len(joint_angles)))  # Count (4 bytes)\r\n\r\n        for angle in joint_angles:\r\n            data.extend(struct.pack('d', angle))  # Each angle (8 bytes)\r\n\r\n        return bytes(data)\r\n\r\n    def deserialize_robot_state(self, data_bytes):\r\n        \"\"\"Deserialize robot state from binary format\"\"\"\r\n        offset = 0\r\n\r\n        # Extract timestamp\r\n        timestamp = struct.unpack_from('d', data_bytes, offset)[0]\r\n        offset += 8\r\n\r\n        # Extract position\r\n        pos_x, pos_y, pos_z = struct.unpack_from('ddd', data_bytes, offset)\r\n        offset += 24\r\n\r\n        # Extract orientation\r\n        roll, pitch, yaw = struct.unpack_from('ddd', data_bytes, offset)\r\n        offset += 24\r\n\r\n        # Extract joint count and angles\r\n        joint_count = struct.unpack_from('I', data_bytes, offset)[0]\r\n        offset += 4\r\n\r\n        joint_angles = []\r\n        for i in range(joint_count):\r\n            angle = struct.unpack_from('d', data_bytes, offset)[0]\r\n            offset += 8\r\n            joint_angles.append(angle)\r\n\r\n        return {\r\n            'timestamp': timestamp,\r\n            'position': {'x': pos_x, 'y': pos_y, 'z': pos_z},\r\n            'orientation': {'roll': roll, 'pitch': pitch, 'yaw': yaw},\r\n            'joint_angles': joint_angles\r\n        }\n"})}),"\n",(0,i.jsx)(e.h3,{id:"data-compression-for-sensor-streams",children:"Data Compression for Sensor Streams"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"using System.IO;\r\nusing System.IO.Compression;\r\n\r\npublic class SensorDataCompressor\r\n{\r\n    public static byte[] CompressLidarData(float[] ranges)\r\n    {\r\n        // Quantize range values to reduce precision (acceptable for visualization)\r\n        byte[] quantizedData = new byte[ranges.Length * 2]; // 16-bit per range\r\n\r\n        for (int i = 0; i < ranges.Length; i++)\r\n        {\r\n            // Quantize to 16-bit integer (0-65535 for 0-65.535m range)\r\n            ushort quantizedValue = (ushort)Mathf.Clamp(ranges[i] * 1000, 0, 65535);\r\n            byte[] bytes = BitConverter.GetBytes(quantizedValue);\r\n            Array.Copy(bytes, 0, quantizedData, i * 2, 2);\r\n        }\r\n\r\n        // Compress the quantized data\r\n        using (var output = new MemoryStream())\r\n        {\r\n            using (var deflateStream = new DeflateStream(output, CompressionLevel.Optimal))\r\n            {\r\n                deflateStream.Write(quantizedData, 0, quantizedData.Length);\r\n            }\r\n            return output.ToArray();\r\n        }\r\n    }\r\n\r\n    public static float[] DecompressLidarData(byte[] compressedData)\r\n    {\r\n        // Decompress the data\r\n        using (var input = new MemoryStream(compressedData))\r\n        using (var deflateStream = new DeflateStream(input, CompressionMode.Decompress))\r\n        using (var output = new MemoryStream())\r\n        {\r\n            deflateStream.CopyTo(output);\r\n            byte[] decompressedData = output.ToArray();\r\n\r\n            // Convert back to float array\r\n            float[] ranges = new float[decompressedData.Length / 2];\r\n            for (int i = 0; i < ranges.Length; i++)\r\n            {\r\n                ushort value = BitConverter.ToUInt16(decompressedData, i * 2);\r\n                ranges[i] = value / 1000.0f; // Convert back to meters\r\n            }\r\n\r\n            return ranges;\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,i.jsx)(e.h3,{id:"connection-resilience",children:"Connection Resilience"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using System.Collections;\r\nusing UnityEngine;\r\n\r\npublic class ConnectionManager : MonoBehaviour\r\n{\r\n    [Header("Reconnection Settings")]\r\n    public int maxReconnectionAttempts = 5;\r\n    public float reconnectionDelay = 2f;\r\n    public float heartbeatInterval = 5f;\r\n\r\n    private int reconnectionAttempts = 0;\r\n    private bool isConnected = false;\r\n    private Coroutine heartbeatCoroutine;\r\n\r\n    void OnConnectionLost()\r\n    {\r\n        isConnected = false;\r\n\r\n        if (heartbeatCoroutine != null)\r\n        {\r\n            StopCoroutine(heartbeatCoroutine);\r\n        }\r\n\r\n        if (reconnectionAttempts < maxReconnectionAttempts)\r\n        {\r\n            StartCoroutine(AttemptReconnection());\r\n        }\r\n        else\r\n        {\r\n            Debug.LogError("Maximum reconnection attempts reached. Manual intervention required.");\r\n        }\r\n    }\r\n\r\n    IEnumerator AttemptReconnection()\r\n    {\r\n        reconnectionAttempts++;\r\n        Debug.LogWarning($"Attempting reconnection ({reconnectionAttempts}/{maxReconnectionAttempts})...");\r\n\r\n        yield return new WaitForSeconds(reconnectionDelay);\r\n\r\n        // Try to reconnect\r\n        bool success = AttemptConnection();\r\n\r\n        if (success)\r\n        {\r\n            Debug.Log("Reconnection successful!");\r\n            isConnected = true;\r\n            reconnectionAttempts = 0;\r\n\r\n            // Restart heartbeat\r\n            heartbeatCoroutine = StartCoroutine(SendHeartbeat());\r\n        }\r\n        else\r\n        {\r\n            StartCoroutine(AttemptReconnection()); // Recursive retry\r\n        }\r\n    }\r\n\r\n    bool AttemptConnection()\r\n    {\r\n        try\r\n        {\r\n            // Implementation of connection attempt\r\n            return true; // Placeholder\r\n        }\r\n        catch\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    IEnumerator SendHeartbeat()\r\n    {\r\n        while (isConnected)\r\n        {\r\n            SendHeartbeatMessage();\r\n\r\n            yield return new WaitForSeconds(heartbeatInterval);\r\n        }\r\n    }\r\n\r\n    void SendHeartbeatMessage()\r\n    {\r\n        // Send simple heartbeat message to verify connection\r\n    }\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices-for-integration",children:"Best Practices for Integration"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Modular Design"}),": Keep communication modules separate from visualization logic"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Configuration Management"}),": Use configuration files for connection parameters"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Error Isolation"}),": Ensure communication failures don't crash the visualization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance Monitoring"}),": Track latency and bandwidth usage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Graceful Degradation"}),": Fallback mechanisms when connection is lost"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security"}),": Secure communication channels for production deployments"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsx)(e.h3,{id:"synchronization-problems",children:"Synchronization Problems"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Check time step consistency between Gazebo and Unity"}),"\n",(0,i.jsx)(e.li,{children:"Verify coordinate system alignment"}),"\n",(0,i.jsx)(e.li,{children:"Monitor network latency and packet loss"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"performance-bottlenecks",children:"Performance Bottlenecks"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Profile both Gazebo and Unity independently"}),"\n",(0,i.jsx)(e.li,{children:"Optimize data transmission frequency"}),"\n",(0,i.jsx)(e.li,{children:"Use efficient serialization formats"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"data-integrity",children:"Data Integrity"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement checksums for critical data"}),"\n",(0,i.jsx)(e.li,{children:"Validate incoming data ranges"}),"\n",(0,i.jsx)(e.li,{children:"Handle malformed messages gracefully"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(e.p,{children:"With the integration infrastructure established, we'll now create a comprehensive quickstart guide to help users set up their first Gazebo-Unity digital twin system."})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);