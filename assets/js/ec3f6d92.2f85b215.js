"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[2691],{5765:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"book-tutorial/module-1/python-integration","title":"Python Integration with Robotics","description":"This chapter explores how to integrate Python with ROS 2 using rclpy, the Python client library for ROS 2. Python is the dominant language in AI and machine learning, making it crucial for creating intelligent robotic systems.","source":"@site/docs/book-tutorial/module-1/02-python-integration.md","sourceDirName":"book-tutorial/module-1","slug":"/book-tutorial/module-1/python-integration","permalink":"/physical-ai-book/docs/book-tutorial/module-1/python-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book-tutorial/module-1/02-python-integration.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Python Integration with Robotics"},"sidebar":"bookTutorial","previous":{"title":"ROS 2 Foundations","permalink":"/physical-ai-book/docs/book-tutorial/module-1/intro"},"next":{"title":"Humanoid Structure & URDF","permalink":"/physical-ai-book/docs/book-tutorial/module-1/humanoid-urdf"}}');var s=n(4848),t=n(8453);const i={sidebar_position:3,title:"Python Integration with Robotics"},l="Python Integration with Robotics: Bridging AI and Control",a={},c=[{value:"Why Python for Robotics?",id:"why-python-for-robotics",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:3},{value:"Basic Node Structure",id:"basic-node-structure",level:3},{value:"Creating Control Nodes",id:"creating-control-nodes",level:2},{value:"Publisher Node Example",id:"publisher-node-example",level:3},{value:"Subscriber Node Example",id:"subscriber-node-example",level:3},{value:"Event Loops and Callbacks",id:"event-loops-and-callbacks",level:2},{value:"Understanding the ROS 2 Event Loop",id:"understanding-the-ros-2-event-loop",level:3},{value:"Advanced Callback Patterns",id:"advanced-callback-patterns",level:3},{value:"Python Robotics Libraries Integration",id:"python-robotics-libraries-integration",level:2},{value:"Computer Vision with OpenCV",id:"computer-vision-with-opencv",level:3},{value:"Machine Learning Integration",id:"machine-learning-integration",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Robust Error Handling",id:"robust-error-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Optimizing Python Nodes",id:"optimizing-python-nodes",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"python-integration-with-robotics-bridging-ai-and-control",children:"Python Integration with Robotics: Bridging AI and Control"})}),"\n",(0,s.jsx)(r.p,{children:"This chapter explores how to integrate Python with ROS 2 using rclpy, the Python client library for ROS 2. Python is the dominant language in AI and machine learning, making it crucial for creating intelligent robotic systems."}),"\n",(0,s.jsx)(r.h2,{id:"why-python-for-robotics",children:"Why Python for Robotics?"}),"\n",(0,s.jsx)(r.p,{children:"Python has become the de facto standard for AI and machine learning applications. Integrating Python with ROS 2 allows you to:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Leverage powerful AI libraries (TensorFlow, PyTorch, scikit-learn)"}),"\n",(0,s.jsx)(r.li,{children:"Rapidly prototype robotic applications"}),"\n",(0,s.jsx)(r.li,{children:"Implement complex algorithms with minimal code"}),"\n",(0,s.jsx)(r.li,{children:"Interface with computer vision and perception systems"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"rclpy"})," is the Python client library for ROS 2. It provides Python bindings for the ROS 2 client library (rcl) and enables Python developers to create ROS 2 nodes."]}),"\n",(0,s.jsx)(r.h3,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# rclpy comes pre-installed with ROS 2\r\n# Verify installation\r\npython3 -c \"import rclpy; print('rclpy available')\"\n"})}),"\n",(0,s.jsx)(r.h3,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass PythonRobotNode(Node):\r\n    def __init__(self):\r\n        super().__init__('python_robot_node')\r\n        self.get_logger().info('Python Robot Node initialized')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    node = PythonRobotNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Node interrupted by user')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.h2,{id:"creating-control-nodes",children:"Creating Control Nodes"}),"\n",(0,s.jsx)(r.h3,{id:"publisher-node-example",children:"Publisher Node Example"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32\r\nimport math\r\nimport time\r\n\r\nclass SensorPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_publisher')\r\n\r\n        # Create publisher\r\n        self.publisher = self.create_publisher(Float32, 'sensor_data', 10)\r\n\r\n        # Create timer for periodic publishing\r\n        self.timer = self.create_timer(0.1, self.publish_sensor_data)\r\n\r\n        # Initialize sensor simulation variables\r\n        self.time_offset = 0.0\r\n\r\n        self.get_logger().info('Sensor publisher started')\r\n\r\n    def publish_sensor_data(self):\r\n        msg = Float32()\r\n\r\n        # Simulate sensor data (e.g., distance sensor with sine wave pattern)\r\n        sensor_value = 1.0 + 0.5 * math.sin(self.time_offset)\r\n        msg.data = sensor_value\r\n\r\n        self.publisher.publish(msg)\r\n        self.get_logger().info(f'Published sensor data: {msg.data:.3f}')\r\n\r\n        self.time_offset += 0.1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SensorPublisher()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Sensor publisher stopped')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.h3,{id:"subscriber-node-example",children:"Subscriber Node Example"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32\r\nimport numpy as np\r\n\r\nclass ControlSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('control_subscriber')\r\n\r\n        # Create subscriber\r\n        self.subscription = self.create_subscription(\r\n            Float32,\r\n            'sensor_data',\r\n            self.sensor_callback,\r\n            10\r\n        )\r\n\r\n        # Initialize control variables\r\n        self.recent_values = []\r\n        self.control_output = 0.0\r\n\r\n        self.get_logger().info('Control subscriber initialized')\r\n\r\n    def sensor_callback(self, msg):\r\n        # Store recent values for filtering\r\n        self.recent_values.append(msg.data)\r\n        if len(self.recent_values) > 10:\r\n            self.recent_values.pop(0)\r\n\r\n        # Simple moving average filter\r\n        if len(self.recent_values) > 0:\r\n            avg_value = sum(self.recent_values) / len(self.recent_values)\r\n\r\n            # Implement control logic\r\n            self.control_output = self.compute_control(avg_value)\r\n\r\n            self.get_logger().info(\r\n                f'Sensor: {msg.data:.3f}, Filtered: {avg_value:.3f}, Control: {self.control_output:.3f}'\r\n            )\r\n\r\n    def compute_control(self, sensor_value):\r\n        # Simple proportional controller\r\n        target_value = 1.0\r\n        error = target_value - sensor_value\r\n        control_gain = 2.0\r\n        return control_gain * error\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ControlSubscriber()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Control subscriber stopped')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.h2,{id:"event-loops-and-callbacks",children:"Event Loops and Callbacks"}),"\n",(0,s.jsx)(r.p,{children:"Understanding event loops and callbacks is crucial for creating responsive robotic applications."}),"\n",(0,s.jsx)(r.h3,{id:"understanding-the-ros-2-event-loop",children:"Understanding the ROS 2 Event Loop"}),"\n",(0,s.jsxs)(r.p,{children:["The ROS 2 event loop handles message processing, service calls, and timer callbacks. When you call ",(0,s.jsx)(r.code,{children:"rclpy.spin()"}),", it enters a loop that:"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Checks for incoming messages"}),"\n",(0,s.jsx)(r.li,{children:"Executes callbacks for received messages"}),"\n",(0,s.jsx)(r.li,{children:"Runs timer callbacks at specified intervals"}),"\n",(0,s.jsx)(r.li,{children:"Processes service requests"}),"\n",(0,s.jsx)(r.li,{children:"Handles parameter updates"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"advanced-callback-patterns",children:"Advanced Callback Patterns"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String, Float32\r\nfrom sensor_msgs.msg import LaserScan\r\nimport threading\r\nimport time\r\n\r\nclass AdvancedCallbackNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'advanced_callback_node\')\r\n\r\n        # Multiple subscribers\r\n        self.sensor_sub = self.create_subscription(\r\n            LaserScan, \'laser_scan\', self.laser_callback, 10)\r\n\r\n        self.command_sub = self.create_subscription(\r\n            String, \'robot_command\', self.command_callback, 10)\r\n\r\n        # Publishers\r\n        self.status_pub = self.create_publisher(String, \'robot_status\', 10)\r\n        self.velocity_pub = self.create_publisher(Float32, \'motor_velocity\', 10)\r\n\r\n        # Timer for periodic tasks\r\n        self.timer = self.create_timer(0.5, self.periodic_task)\r\n\r\n        # Shared data with thread safety\r\n        self.lock = threading.Lock()\r\n        self.laser_data = None\r\n        self.last_command = "idle"\r\n        self.is_running = True\r\n\r\n        self.get_logger().info(\'Advanced callback node initialized\')\r\n\r\n    def laser_callback(self, msg):\r\n        """Handle laser scan data"""\r\n        with self.lock:\r\n            self.laser_data = {\r\n                \'ranges\': msg.ranges,\r\n                \'min_range\': msg.range_min,\r\n                \'max_range\': msg.range_max,\r\n                \'angle_min\': msg.angle_min,\r\n                \'angle_max\': msg.angle_max\r\n            }\r\n\r\n        # Process laser data immediately\r\n        self.process_obstacle_detection()\r\n\r\n    def command_callback(self, msg):\r\n        """Handle robot commands"""\r\n        with self.lock:\r\n            self.last_command = msg.data\r\n            self.get_logger().info(f\'Received command: {msg.data}\')\r\n\r\n        # Execute command-specific logic\r\n        self.execute_command(msg.data)\r\n\r\n    def periodic_task(self):\r\n        """Periodic task executed by timer"""\r\n        with self.lock:\r\n            status_msg = String()\r\n            status_msg.data = f\'Running - Command: {self.last_command}\'\r\n            self.status_pub.publish(status_msg)\r\n\r\n    def process_obstacle_detection(self):\r\n        """Process laser data for obstacle detection"""\r\n        with self.lock:\r\n            if self.laser_data:\r\n                ranges = self.laser_data[\'ranges\']\r\n                min_distance = min(ranges) if ranges else float(\'inf\')\r\n\r\n                if min_distance < 1.0:  # Obstacle within 1 meter\r\n                    self.get_logger().warn(f\'Obstacle detected at {min_distance:.2f}m\')\r\n                    self.avoid_obstacle()\r\n\r\n    def execute_command(self, command):\r\n        """Execute specific robot commands"""\r\n        if command == \'move_forward\':\r\n            self.move_forward()\r\n        elif command == \'turn_left\':\r\n            self.turn_left()\r\n        elif command == \'stop\':\r\n            self.stop_robot()\r\n\r\n    def move_forward(self):\r\n        """Move robot forward"""\r\n        vel_msg = Float32()\r\n        vel_msg.data = 1.0  # Set forward velocity\r\n        self.velocity_pub.publish(vel_msg)\r\n        self.get_logger().info(\'Moving forward\')\r\n\r\n    def turn_left(self):\r\n        """Turn robot left"""\r\n        vel_msg = Float32()\r\n        vel_msg.data = 0.5  # Differential velocity for turning\r\n        self.velocity_pub.publish(vel_msg)\r\n        self.get_logger().info(\'Turning left\')\r\n\r\n    def stop_robot(self):\r\n        """Stop robot movement"""\r\n        vel_msg = Float32()\r\n        vel_msg.data = 0.0\r\n        self.velocity_pub.publish(vel_msg)\r\n        self.get_logger().info(\'Robot stopped\')\r\n\r\n    def avoid_obstacle(self):\r\n        """Simple obstacle avoidance behavior"""\r\n        vel_msg = Float32()\r\n        vel_msg.data = -0.5  # Move backward briefly\r\n        self.velocity_pub.publish(vel_msg)\r\n        self.get_logger().info(\'Avoiding obstacle\')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = AdvancedCallbackNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Advanced callback node stopped\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,s.jsx)(r.h2,{id:"python-robotics-libraries-integration",children:"Python Robotics Libraries Integration"}),"\n",(0,s.jsx)(r.h3,{id:"computer-vision-with-opencv",children:"Computer Vision with OpenCV"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\nimport cv2\r\nimport numpy as np\r\n\r\nclass VisionNode(Node):\r\n    def __init__(self):\r\n        super().__init__('vision_node')\r\n\r\n        # Initialize CV bridge\r\n        self.bridge = CvBridge()\r\n\r\n        # Create subscriber for camera images\r\n        self.image_sub = self.create_subscription(\r\n            Image, 'camera/image_raw', self.image_callback, 10)\r\n\r\n        # Create publisher for processed images\r\n        self.processed_pub = self.create_publisher(Image, 'camera/processed', 10)\r\n\r\n        self.get_logger().info('Vision node initialized')\r\n\r\n    def image_callback(self, msg):\r\n        try:\r\n            # Convert ROS image message to OpenCV image\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\")\r\n\r\n            # Process image (example: edge detection)\r\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\r\n            edges = cv2.Canny(gray, 50, 150)\r\n\r\n            # Convert back to ROS message\r\n            processed_msg = self.bridge.cv2_to_imgmsg(edges, \"mono8\")\r\n            processed_msg.header = msg.header  # Preserve header\r\n\r\n            # Publish processed image\r\n            self.processed_pub.publish(processed_msg)\r\n\r\n            self.get_logger().info('Processed image and published result')\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Error processing image: {str(e)}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = VisionNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Vision node stopped')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.h3,{id:"machine-learning-integration",children:"Machine Learning Integration"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32MultiArray, String\r\nimport numpy as np\r\nfrom sklearn.linear_model import LinearRegression\r\n\r\nclass MLControlNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'ml_control_node\')\r\n\r\n        # Create subscriber for sensor data\r\n        self.sensor_sub = self.create_subscription(\r\n            Float32MultiArray, \'sensor_array\', self.sensor_callback, 10)\r\n\r\n        # Create publisher for control commands\r\n        self.control_pub = self.create_publisher(String, \'ml_control_output\', 10)\r\n\r\n        # Initialize ML model\r\n        self.model = LinearRegression()\r\n        self.is_trained = False\r\n        self.training_data = []\r\n\r\n        self.get_logger().info(\'ML control node initialized\')\r\n\r\n    def sensor_callback(self, msg):\r\n        sensor_values = np.array(msg.data).reshape(1, -1)\r\n\r\n        if self.is_trained:\r\n            # Use trained model to predict action\r\n            prediction = self.model.predict(sensor_values)\r\n            action = self.determine_action(prediction[0])\r\n\r\n            control_msg = String()\r\n            control_msg.data = action\r\n            self.control_pub.publish(control_msg)\r\n\r\n            self.get_logger().info(f\'Predicted action: {action}\')\r\n        else:\r\n            # Collect training data (in real application, you\'d have a training phase)\r\n            self.collect_training_data(sensor_values)\r\n\r\n    def determine_action(self, prediction_value):\r\n        """Map prediction to robot action"""\r\n        if prediction_value > 0.7:\r\n            return "move_forward"\r\n        elif prediction_value > 0.3:\r\n            return "turn_right"\r\n        elif prediction_value > -0.3:\r\n            return "turn_left"\r\n        else:\r\n            return "stop"\r\n\r\n    def collect_training_data(self, sensor_values):\r\n        """Collect data for training (simplified example)"""\r\n        # In a real scenario, you\'d collect labeled data\r\n        # This is just a placeholder for the concept\r\n        pass\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = MLControlNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'ML control node stopped\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,s.jsx)(r.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,s.jsx)(r.h3,{id:"robust-error-handling",children:"Robust Error Handling"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nimport traceback\r\n\r\nclass RobustNode(Node):\r\n    def __init__(self):\r\n        super().__init__('robust_node')\r\n\r\n        self.publisher = self.create_publisher(String, 'robust_topic', 10)\r\n        self.timer = self.create_timer(1.0, self.robust_timer_callback)\r\n\r\n        self.get_logger().info('Robust node initialized')\r\n\r\n    def robust_timer_callback(self):\r\n        try:\r\n            # Perform potentially risky operation\r\n            result = self.perform_calculation()\r\n\r\n            msg = String()\r\n            msg.data = f'Result: {result}'\r\n            self.publisher.publish(msg)\r\n\r\n        except ValueError as e:\r\n            self.get_logger().error(f'Value error: {str(e)}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Unexpected error: {str(e)}')\r\n            self.get_logger().error(f'Traceback: {traceback.format_exc()}')\r\n\r\n    def perform_calculation(self):\r\n        # Example calculation that might fail\r\n        import random\r\n        value = random.random()\r\n\r\n        if value < 0.1:  # Simulate occasional failure\r\n            raise ValueError(\"Simulated calculation error\")\r\n\r\n        return value * 100\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = RobustNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Robust node stopped by user')\r\n    except Exception as e:\r\n        node.get_logger().error(f'Fatal error: {str(e)}')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(r.h3,{id:"optimizing-python-nodes",children:"Optimizing Python Nodes"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Use appropriate timer rates"}),": Don't create timers that fire too frequently"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Minimize data copying"}),": Be mindful of large message types"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Use efficient data structures"}),": Consider numpy arrays for numerical computations"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Profile your code"}),": Use profiling tools to identify bottlenecks"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nimport weakref\r\n\r\nclass MemoryEfficientNode(Node):\r\n    def __init__(self):\r\n        super().__init__('memory_efficient_node')\r\n\r\n        self.subscription = self.create_subscription(\r\n            String, 'input_topic', self.memory_safe_callback, 10)\r\n\r\n        # Use weak references to avoid circular references\r\n        self.processed_messages = []\r\n\r\n        # Limit message history to prevent memory leaks\r\n        self.max_history = 100\r\n\r\n    def memory_safe_callback(self, msg):\r\n        # Process message\r\n        processed = self.process_message(msg)\r\n\r\n        # Store with size limit\r\n        self.processed_messages.append(processed)\r\n        if len(self.processed_messages) > self.max_history:\r\n            self.processed_messages.pop(0)  # Remove oldest\r\n\r\n    def process_message(self, msg):\r\n        return f\"Processed: {msg.data}\"\n"})}),"\n",(0,s.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(r.p,{children:"Python integration with ROS 2 through rclpy enables powerful robotic applications that combine AI capabilities with robotic control systems. Key takeaways include:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Event-driven architecture"}),": Understanding callbacks and the ROS 2 event loop"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Integration capabilities"}),": Connecting AI libraries with robotic systems"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Error handling"}),": Implementing robust error management"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Performance considerations"}),": Optimizing Python nodes for real-time applications"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"In the next chapter, we'll explore how to describe robots using URDF and connect these descriptions to our ROS 2 control systems."})]})}function m(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var o=n(6540);const s={},t=o.createContext(s);function i(e){const r=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(t.Provider,{value:r},e.children)}}}]);